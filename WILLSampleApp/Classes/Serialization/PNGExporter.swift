//
//  PNGExporter.swift
//  WILLSampleApp
//
//  Created by Mincho Dzhagalov on 22.10.21.
//  Copyright Â© 2021 Mincho Dzhagalov. All rights reserved.
//
//

import Foundation
import WacomInk

class PNGExporter {
    private var mConvexHullChainProducer = ConvexHullChainProducer()
    private var mPolygonMerger = PolygonMerger()
    private var mPolygonSimplifier = PolygonSimplifier(epsilon: 0.1)
    
    func exportToPNG(inkDocument: InkModel, pngWidth: Float, pngHeight: Float, fit: Bool) -> UIImage? {
        return drawStrokes(inkDocument: inkDocument, pngWidth: pngWidth, pngHeight: pngHeight, fit: true)
    }
    
    func drawStrokes(inkDocument: InkModel, pngWidth: Float, pngHeight: Float, fit: Bool) -> UIImage? {
        if inkDocument.inkTree.root != nil {
            let enumerator = inkDocument.inkTree.root?.getRecursiveEnumerator()
            
            let renderFormat = UIGraphicsImageRendererFormat()
            renderFormat.scale = 1
            
            let renderer = UIGraphicsImageRenderer(size: CGSize(width: CGFloat(pngWidth), height: CGFloat(pngHeight)), format: renderFormat)
            
            let drawingActions: UIGraphicsImageRenderer.DrawingActions = {_ in
                // process every stroke by using the appropriate vector brush geometry
                while ((enumerator?.next()) != nil) {
                    if let strokeNode = enumerator?.current as? StrokeNode {
                        if let brushUri = strokeNode.stroke.style.brushUri {
                            let brush = inkDocument.brushes.tryGetBrush(brushName: brushUri)
                            // only exports vector strokes
                            if let vectorBrush = brush as? VectorBrush {
                                var vb: Geometry.VectorBrush
                                
                                // if the brush has geometry
                                if vectorBrush.brushPolygons?.count ?? 0 > 0 {
                                    var brushPolygons = [BrushPolygon]()
                                    
                                    for polygon in vectorBrush.brushPolygons! {
                                        var newPoints = [DIPoint2]()
                                        for point in polygon.points {
                                            newPoints.append(DIPoint2(x: point.x, y: point.y))
                                        }
                                        
                                        brushPolygons.append(try! BrushPolygon.createNormalized(minScale: polygon.minScale, points: newPoints))
                                    }
                                    
                                    vb = try! Geometry.VectorBrush(polygons: brushPolygons)
                                } else if vectorBrush.brushPrototypeURIs.count > 0 { // the geometry was missing, so it needs to be generated by using the supplied URIs
                                    var brushPolygons = [BrushPolygon]()
                                    
                                    for uri in vectorBrush.brushPrototypeURIs {
                                        brushPolygons.append(try! URIShapeResolver.resolveShape(uri: uri))
                                    }
                                    
                                    vb = try! Geometry.VectorBrush(polygons: brushPolygons)
                                } else {
                                    continue
                                }
                                
                                self.drawStroke(stroke: strokeNode.stroke, vectorBrush: vb)
                            }
                        }
                    }
                }
            }
            
            return UIImage(data: renderer.pngData(actions: drawingActions))?.withBackground(color: .white) ?? UIImage()
        }
        
        return nil
    }
    
    private func drawStroke(stroke: Stroke, vectorBrush: WacomInk.Geometry.VectorBrush) {
        let alpha: Float = (stroke.style.pathPointProperties?.alpha)!
        
        // go through the pipeline and process the countours
        let splineInterpolator = CurvatureBasedInterpolator()
        let brushApplier = try! BrushApplier(brush: vectorBrush)
        let readOnlySpline = try! stroke.getSpline()
        let spline = try! Spline(path: Path(source: readOnlySpline.pathData, layoutMask: stroke.getSpline().layoutMask), tStart: readOnlySpline.tStart, tFinal: readOnlySpline.tFinal)
        let points = try! splineInterpolator.add(isFirst: true, isLast: true, addition: spline, prediction: nil)
        let polys = try! brushApplier.add(isFirst: true, isLast: true, addition: points.addition, prediction: points.prediction)
        let hulls = try! mConvexHullChainProducer.add(isFirst: true, isLast: true, addition: polys.addition, prediction: polys.prediction)
        let merged = try! mPolygonMerger.add(isFirst: true, isLast: true, addition: hulls.addition, prediction: hulls.prediction)
        let simplified = try! mPolygonSimplifier.add(isFirst: true, isLast: true, addition: merged.addition, prediction: merged.prediction)
        
        if simplified.addition == nil {
            return
        }
        
        // convert the points returned from the pipeline to bezier path and render the path in the drawing context
        var bezierPath: UIBezierPath?
        generateBezierPolys(simplified.addition!, result: &bezierPath)
        
        let red = CGFloat(stroke.style.pathPointProperties?.red ?? 0)
        let green = CGFloat(stroke.style.pathPointProperties?.green ?? 0)
        let blue = CGFloat(stroke.style.pathPointProperties?.blue ?? 0)
        
        let strokeColor = UIColor(red: red, green: green, blue: blue, alpha: CGFloat(alpha))
        
        strokeColor.setFill()
        bezierPath?.fill()
    }
}
